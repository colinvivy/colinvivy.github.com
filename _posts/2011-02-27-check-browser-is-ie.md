---
layout: post
title: 区分IE和非IE的最短判断
keywords: Javascript
category: Front-end
excerpt: 由于会议邀请者的系统时间出错，我被早到了一个小时到达会议室，闲着无聊，就顺便看看新闻，在JE里面看到一个“区分IE和非IE的最短判断”，帖子中的解释是：根据IE在对数组使用toString方法时报错来判断，代码大致如下
---

由于会议邀请者的系统时间出错，我被早到了一个小时到达会议室，闲着无聊，就顺便看看新闻，在JE里面看到一个“区分IE和非IE的最短判断”，帖子中的解释是：根据IE在对数组使用toString方法时报错来判断，代码大致如下：

    if (+[1,]){
        alert('您正在使用非IE浏览器');
    }else {
        alert('您正在使用IE浏览器');
    }

Well，这里使用了一元加法运算符，对这个不了解到可以看看下面的代码（关于对数组使用一元加法运算符，我暂时没找到正规文档，只好以实例来说明来推测）：

    // 当数组只有1个元素时，返回这个数组元素
    alert(+[1]);
    // 当数组长度大于1时，返回NaN
    alert(+[1,2]);

好吧，其实我想说“区分IE和非IE的最短判断”的是根据IE和标准浏览器对数组容错处理不一致的特性来实现的。

标准浏览器会忽悠数组中最后一个”,” （当作这是开发者不小心写上去的）， 而IE则不会忽略它，而且用undefined来填充最后一个数组元素。

    var a = [1,] ;
    // 查看数组a的length属性 枚举数组
    // 通过这两步可以测试出非IE是忽略掉数组中最后一个空元素的
    // 而IE却用undefined来填充最后一个元素
    alert([1,].length);
    for (var i = 0, le = a.length ; i < le; i++ ) {
        alert(a[i]);
    }
     
    // 由上述得知 +[1,] 相当于 +[1, undefined] 
    // 根据上面一元运算符的实例，你不难想到在IE下+[1,]会返回NaN了
    alert(+[1,]);
    alert(+[1,undefined]);

BTW：最近时间排得紧，走路都在想些事情，以至于生活方面的事情都有点昏昏的，买东西忘了拿找零，取钱忘记了拿。一心无二用，以后做什么事情都要专注，哪怕是取钱，也要盯着带着印钞机余温的RMB从ATM中徐徐吐出，然后收回卡，放好钱包再走人。
